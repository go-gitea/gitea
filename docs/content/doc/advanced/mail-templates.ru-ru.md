---
date: "2019-10-23T17:00:00-03:00"
title: "Почтовые шаблоны"
slug: "mail-templates"
weight: 45
toc: true
draft: false
menu:
  sidebar:
    parent: "advanced"
    name: "Почтовые шаблоны"
    weight: 45
    identifier: "mail-templates"
---

# Почтовые шаблоны

Чтобы создать тему и содержимое электронного письма для определенных операций, Gitea можно настроить с помощью шаблонов. Шаблоны
для этих функций расположены под [`custom` directory](https://docs.gitea.io/en-us/customizing-gitea/).
В Gitea есть внутренний шаблон, который используется по умолчанию, если нет альтернативы.

Пользовательские шаблоны загружаются при запуске Gitea. Внесенные в них изменения не распознаются, пока Gitea не будет перезапущена снова.

## Почтовые уведомления, поддерживающие шаблоны

В настоящее время шаблоны используются для следующих событий уведомления:

| Действие      | Применение                                                                                                   |
|---------------|--------------------------------------------------------------------------------------------------------------|
| `new`         | Создана новая задача или pull request.                                                                       |
| `comment`     | Новый комментарий был создан в существующей задаче или pull request.                                         |
| `close`       | Задача или pull request.                                                                                     |
| `reopen`      | Задача или pull request был открыт повторно.                                                                 |
| `review`      | Главный комментарий отзыва в pull request'е.                                                                 |
| `approve`     | Главный комментарий одобряющего обзора для pull request'а.                                                   |
| `reject`      | Заглавный комментарий обзора, запрашивающего изменения для pull request'а.                                   |
| `code`        | Один комментарий к коду pull request'а.                                                                      |
| `assigned`    | Использовано было назначено задаче или pull request'а.                                                       |
| `default`     | Любое действие, не включенное в вышеуказанные категории, или когда соответствующий шаблон категории отсутствует. |

Путь к шаблону конкретного типа сообщения:

```
custom/templates/mail/{action type}/{action name}.tmpl
```

Где `{action type}` - это одно из `issue` или`pull` (для pull request'ов), а `{action name}` - одно из перечисленных выше имён.

Например, конкретным шаблоном письма с комментарием в pull request'е является:
```
custom/templates/mail/pull/comment.tmpl
```

Однако создание шаблонов для каждой комбинации типа действия/имени не требуется.
Резервная система используется для выбора подходящего шаблона для события. _Первый существующий_
шаблон в этом списке используется:

* Конкретный шаблон для желаемого **action type** и **action name**.
* Шаблон для действия типа `issue` и желаемый **action name**.
* Шаблон для желаемого **action type**, название действия `default`.
* Шаблон для действия типа `issue`, название действия `default`.

Единственным обязательным шаблоном является тип действия `issue`, имя действия `default`, который уже встроен в Gitea,
если он не переопределен пользователем в каталоге `custom`.

## Синтаксис шаблона

Почтовые шаблоны - это текстовые файлы в кодировке UTF-8, которые должны соответствовать одному из следующих форматов:

```
Текст и макросы для темы
------------
Текст и макросы для тела письма
```

или

```
Текст и макросы для тела письма
```

Указание раздела _тема_ необязательно (и, следовательно, также и разделитель пунктирной линии). При использовании разделителя между
шаблонами _темы_ и _тело письма_ требуется не менее трёх тире; в разделительной строке нельзя использовать другие символы.


_Тема_ в _теле письма_ анализируется [Golang's template engine](https://golang.org/pkg/text/template/) и
предоставляются с _контекстом метаданных_, собранным для каждого уведомления. Контекст содержит следующие элементы:

| Название           | Тип              | Доступно      | Применение                                                                                                                                           |
|--------------------|------------------|---------------|------------------------------------------------------------------------------------------------------------------------------------------------------|
| `.FallbackSubject` | string           | Всегда        | Строка темы по умолчанию. Смотри ниже.                                                                                                               |
| `.Subject`         | string           | Только в теле | _Тема_, однажды решённая.                                                                                                                            |
| `.Body`            | string           | Всегда        | Сообщение о задаче, запрос на pull request, преобразованное из Markdown в HTML и обработанное. Не путайте с _телом письма_.                          |
| `.Link`            | string           | Всегда        | Адрес исходной задачи, pull request'а или комментария.                                                                                               |
| `.Issue`           | models.Issue     | Всегда        | Задача (или pull request), являющаяся источником уведомления. Чтобы получить данные, относящиеся к запросу на перенос (например, `HasMerged`), можно использовать `.Issue.PullRequest`, но следует соблюдать осторожность, так как это поле будет иметь значение `nil`, если задача *не* pull request. |
| `.Comment`         | models.Comment   | Если это применимо | Если уведомление получено из комментария, добавленного к задаче или pull request'у, оно будет содержать информацию о комментарии.               |
| `.IsPull`          | bool             | Всегда        | `true`, если почтовое уведомление связано с pull request'ом (например, `.Issue.PullRequest` не `nil`).                                               |
| `.Repo`            | string           | Всегда        | Имя репозитория, включая имя владельца (например, `mike/stuff`)                                                                                      |
| `.User`            | models.User      | Всегда        | Владелец репозитория, из которого произошло событие. Чтобы получить имя пользователя (например, `mike`), можно использовать`.User.Name`.             |
| `.Doer`            | models.User      | Всегда        | Пользователь, выполнивший действие, вызвавшее событие уведомления. Чтобы получить имя пользователя (например, `rhonda`), можно использовать`.Doer.Name`. |
| `.IsMention`       | bool             | Всегда        | `true`, если это уведомление было создано только потому, что пользователь был упомянут в комментарии, но не был подписан на источник. Будет `false`, если получатель подписан на выпуск или репозиторий. |
| `.SubjectPrefix`   | string           | Всегда        | `Re: ` если уведомление не о проблеме или создании pull request'а; в противном случае - пустая строка.                                               |
| `.ActionType`      | string           | Всегда        | `"issue"` или `"pull"`. Будет соответствовать фактическому _типу_ действия_ независимо от того, какой шаблон был выбран.                             |
| `.ActionName`      | string           | Всегда        | Это будет один из типов действия, описанных выше (`new`, `comment` и т.д.), И он будет соответствовать фактическому _имя действия_ независимо от того, какой шаблон был выбран. |
| `.ReviewComments`  | []models.Comment | Всегда        | Список комментариев к коду в обзоре. Текст комментария будет в `.RenderedContent`, а ссылочный код будет в `.Patch`.                                 |

Все имена чувствительны к регистру.

### Часть шаблона - _Тема_

Механизм шаблонов, используемый для _темы_ почты, - это golang [`text/template`](https://golang.org/pkg/text/template/).
Пожалуйста, обратитесь к связанной документации для получения подробной информации о его синтаксисе.

_Тема_ создаётся с использованием следующих шагов:

* Шаблон выбирается в соответствии с типом уведомления и присутствующими шаблонами.
* Шаблон анализируется и разрешается (например, `{{.Issue.Index}}` преобразуется в номер задачи
  или pull request).
* Все символы, похожие на пробелы (например, `TAB`, `LF` и т.д.), Преобразуются в обычные пробелы.
* Все начальные, конечные и избыточные пробелы удаляются.
* Строка усекается до первых 256 рун (символов).

Если конечным результатом является пустая строка, **или** шаблон темы не был доступен (т.е. Выбранный шаблон
не включал часть темы), будет использоваться **внутреннее значение по умолчанию** Gitea.

Внутренняя тема по умолчанию (резерв) эквивалентна:

```
{{.SubjectPrefix}}[{{.Repo}}] {{.Issue.Title}} (#.Issue.Index)
```

Например: `Re: [mike/stuff] New color palette (#38)`

Тема Gitea по умолчанию также может быть найдена в шаблоне _metadata_ как `.FallbackSubject` из любого
из двух шаблонов, даже если присутствует действительный шаблон темы.

### _Тело письма_ в шаблоне

Механизм шаблонов, используемый для тела письма в golang [`html/template`](https://golang.org/pkg/html/template/).
Пожалуйста, обратитесь к связанной документации для получения подробной информации о его синтаксисе.

_Почтовое тело_ анализируется после темы письма, поэтому после всех соображений есть дополнительное поле
_metadata_, которое является фактически отображаемой темой.

Ожидаемый результат - HTML (включая структурные элементы, такие как `<html>`, `<body>` и т.д.).
Возможна стилизация с помощью блоков `<style>`, атрибутов `class` и` style`. Однако `html/template`
выполняет некоторые [автоматические экранирования] (https://golang.org/pkg/html/template/#hdr-Contexts), которые следует учитывать.

Вложения (например, изображения или внешние таблицы стилей) не поддерживаются. Однако можно ссылаться и на
другие шаблоны, например, для централизованного предоставления содержимого элемента `<style>`. Внешний шаблон
должен быть помещен в папку `custom/mail` и ссылаться на него относительно этого каталога. Например,
`custom/mail/styles/base.tmpl` можно включить с помощью`{{template styles/base}} `.

Письмо отправляется с помощью `Content-Type: multipart/alternate`, поэтому тело отправляется как в HTML,
так и в текстовом формате. Последнее достигается путём удаления разметки HTML.

## Исправление проблем

Способ отображения почты напрямую зависит от возможностей почтового приложения. Многие почтовые
клиенты даже не поддерживают HTML, поэтому они показывают текстовую версию, включенную в сгенерированное письмо.

Если шаблон не отобразится, это будет замечено только в момент отправки письма.
Тема по умолчанию используется, если шаблон темы не работает, и используется все, что было успешно
обработано из _тела письма_, без учёта всего остального.

Пожалуйста, обратитесь к [Gitea's logs](https://docs.gitea.io/en-us/logging-configuration/) для сообщений об ошибках в случае проблем.

## Пример

`custom/templates/mail/issue/default.tmpl`:

```
[{{.Repo}}] @{{.Doer.Name}}
{{if eq .ActionName "new"}}
    created
{{else if eq .ActionName "comment"}}
    commented on
{{else if eq .ActionName "close"}}
    closed
{{else if eq .ActionName "reopen"}}
    reopened
{{else}}
    updated
{{end}}
{{if eq .ActionType "issue"}}
    issue
{{else}}
    pull request
{{end}}
#{{.Issue.Index}}: {{.Issue.Title}}
------------
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>{{.Subject}}</title>
</head>

<body>
    {{if .IsMention}}
    <p>
        You are receiving this because @{{.Doer.Name}} mentioned you.
    </p>
    {{end}}
    <p>
        <p>
        <a href="{{AppURL}}/{{.Doer.LowerName}}">@{{.Doer.Name}}</a>
        {{if not (eq .Doer.FullName "")}}
            ({{.Doer.FullName}})
        {{end}}
        {{if eq .ActionName "new"}}
            created
        {{else if eq .ActionName "close"}}
            closed
        {{else if eq .ActionName "reopen"}}
            reopened
        {{else}}
            updated
        {{end}}
        <a href="{{.Link}}">{{.Repo}}#{{.Issue.Index}}</a>.
        </p>
        {{if not (eq .Body "")}}
            <h3>Message content:</h3>
            <hr>
            {{.Body | Str2html}}
        {{end}}
    </p>
    <hr>
    <p>
        <a href="{{.Link}}">View it on Gitea</a>.
    </p>
</body>
</html>
```

Этот шаблон производит что-то в этом роде:

#### Тема

> [mike/stuff] @rhonda прокомментировал(а) pull request #38: New color palette

#### Тело письма

> [@rhonda](#) (Rhonda Myers) обновил(а) [mike/stuff#38](#).
>
> #### Содержание сообщения:
>
> \__________________________________________________________________
>
> Майк, я думаю, нам следует немного приглушить хандру.  
> \__________________________________________________________________
> 
> [Посмотреть на Gitea](#).

## Продвинутое

Система шаблонов содержит несколько функций, которые можно использовать для дальнейшей обработки
и форматирования сообщений. Вот список некоторых из них:

| Название             | Параметры   | Доступ    | Применение                                                                   |
|----------------------|-------------|-----------|------------------------------------------------------------------------------|
| `AppUrl`             | -           | Любой     | Gitea URL                                                                    |
| `AppName`            | -           | Любой     | Устанавливается из `app.ini`, обычно "Gitea"                                 |
| `AppDomain`          | -           | Любой     | Имя хоста Gitea                                                              |
| `EllipsisString`     | string, int | Любой     | Обрезает строку до указанной длины; при необходимости добавляет многоточие   |
| `Str2html`           | string      | Только тело | Очищает текст, удаляя из него любые HTML-теги.                               |
| `Safe`               | string      | Только тело | Принимает ввод как HTML; может использоваться для `.ReviewComments.RenderedContent`.  |

Это _функции_, а не метаданные, поэтому их нужно использовать:

```
Вот так:           {{Str2html "Escape<my>text"}}
Или так:           {{"Escape<my>text" | Str2html}}
Или так:           {{AppUrl}}
Но не так:         {{.AppUrl}}
```
