// Copyright 2022 The Gitea Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.

// This file is heavily inspired by https://github.com/nicksnyder/go-i18n/tree/main/v2/internal/plural

package main

import (
	"bytes"
	"encoding/xml"
	"flag"
	"fmt"
	"go/format"
	"os"
	"text/template"

	"code.gitea.io/gitea/modules/translation/i18n/plurals/generate"
)

var usage = `%[1]s parses and generates go code for CLDR plural.xml and ordinal.xml.xml

Usage: %[1]s [-v] [-c code.go] [-t test.go] plurals.xml ordinals.xml

`

func main() {
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, usage, os.Args[0])
		flag.PrintDefaults()
	}

	var codeOut, testOut string
	flag.BoolVar(&verbose, "v", false, "verbose output")
	flag.StringVar(&codeOut, "c", "", "file to output generated code")
	flag.StringVar(&testOut, "t", "", "file to output generated tests")
	flag.Parse()

	args := flag.Args()

	if len(args) == 0 {
		args = []string{"plurals.xml"}
	}

	data := &generate.SupplementalData{}

	for _, in := range args {
		buf, err := os.ReadFile(in)
		if err != nil {
			fatalf("failed to read file: %s", err)
		}

		var individual generate.SupplementalData
		if err := xml.Unmarshal(buf, &individual); err != nil {
			fatalf("failed to unmarshal xml: %s", err)
		}
		data.Plurals = append(data.Plurals, individual.Plurals...)
	}

	if verbose {
		count := 0
		groups := 0
		for _, plurals := range data.Plurals {
			for _, localeGroups := range plurals.LocaleGroups {
				count += len(localeGroups.SplitLocales())
				groups++
			}
		}
		verbosef("parsed %d locales in %d groups", count, groups)
	}

	if codeOut != "" {
		if err := runTemplate(codeTemplate, codeOut, data); err != nil {
			fatalf("failed to generate code: %v", err)
		} else {
			verbosef("generated %s", codeOut)
		}
	} else {
		logf("not generating code file (use -c)")
	}

	if testOut != "" {
		if err := runTemplate(testTemplate, testOut, data); err != nil {
			fatalf("failed to generate test code: %v", err)
		} else {
			verbosef("generated %s", testOut)
		}
	} else {
		logf("not generating test file (use -t)")
	}
}

func runTemplate(t *template.Template, filename string, data *generate.SupplementalData) error {
	buf := bytes.NewBuffer(nil)
	if err := t.Execute(buf, data); err != nil {
		return fmt.Errorf("unable to execute template: %w", err)
	}
	bs, err := format.Source(buf.Bytes())
	if err != nil {
		verbosef("Bad source:\n%s", buf.String())
		return fmt.Errorf("unable to format source: %w", err)
	}
	file, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("failed to create file %s because %w", filename, err)
	}
	defer file.Close()
	_, err = file.Write(bs)
	if err != nil {
		return fmt.Errorf("unable to write generated source: %w", err)
	}
	return nil
}

var codeTemplate = template.Must(template.New("codeTemplate").Parse(`// This file is generated by modules/translation/i18n/plurals/generate/main/generate.go DO NOT EDIT
// Copyright 2022 The Gitea Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.

package plurals

// DefaultRules returns a map of Rules generated from CLDR language data.
func DefaultRules() Rules {
	rules := Rules{}
{{range $p, $plurals := .Plurals}}
{{range .LocaleGroups}}
	addPluralRules(rules, {{printf "%q" $plurals.Type}}, {{printf "%#v" .SplitLocales}}, &Rule{
		PluralForms: newPluralFormSet({{range $i, $e := .Rules}}{{if $i}}, {{end}}{{$e.CountTitle}}{{end}}),
		PluralFormFunc: func(ops *Operands) Form { {{range .Rules}}{{if .GoCondition}}
			// {{.Condition}}
			if {{.GoCondition}} {
				return {{.CountTitle}}
			}{{end}}{{end}}
			return Other
		},
	}){{end}}
	{{end}}
	return rules
}
`))

var testTemplate = template.Must(template.New("testTemplate").Parse(`// This file is generated by modules/translation/i18n/plurals/generate/main/generate.go DO NOT EDIT
// Copyright 2022 The Gitea Authors. All rights reserved.
// Use of this source code is governed by a MIT-style
// license that can be found in the LICENSE file.

package plurals

import "testing"

{{range $p, $plurals := .Plurals}}
{{range $i, $localeGroup := .LocaleGroups}}
func Test{{$i}}{{$plurals.Type}}(t *testing.T) {
	var tests []pluralFormTest
	{{range $localeGroup.Rules}}
	{{if .IntegerSamples}}tests = appendIntegerTests(tests, {{printf "%q" $plurals.Type}}, {{.CountTitle}}, {{printf "%#v" .IntegerSamples}}){{end}}
	{{if .DecimalSamples}}tests = appendDecimalTests(tests, {{printf "%q" $plurals.Type}}, {{.CountTitle}}, {{printf "%#v" .DecimalSamples}}){{end}}
	{{end}}
	locales := {{printf "%#v" $localeGroup.SplitLocales}}
	for _, locale := range locales {
	  runTests(t, locale, {{printf "%q" $plurals.Type}}, tests)
  }
}

{{end}}
{{end}}
`))

func logf(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, format+"\n", args...)
}

var verbose bool

func verbosef(format string, args ...interface{}) {
	if verbose {
		logf(format, args...)
	}
}

func fatalf(format string, args ...interface{}) {
	logf("fatal: "+format+"\n", args...)
	os.Exit(1)
}
